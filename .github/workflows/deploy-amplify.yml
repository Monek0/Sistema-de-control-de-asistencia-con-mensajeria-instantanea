name: Deploy Frontend to AWS Amplify

on:
  push:
    branches:
      - main
    paths:
      - 'Plataforma_Atrasos/frontend/**'
      - '.github/workflows/deploy-amplify.yml'
  workflow_run:
    workflows: ["Deploy Backend to AWS Lambda"]
    types:
      - completed
    branches:
      - main
  workflow_dispatch:

jobs:
  deploy:
    name: Deploy Frontend
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: Plataforma_Atrasos/frontend

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 18
          cache: 'npm'
          cache-dependency-path: Plataforma_Atrasos/frontend/package-lock.json

      - name: Install dependencies
        run: |
          # Create .npmrc to handle peer dependencies
          echo "legacy-peer-deps=true" > .npmrc
          
          # Clean install
          npm cache clean --force
          npm install --legacy-peer-deps

      - name: Fix Ajv errors
        run: |
          # Create a simplified patch script for Ajv-related issues
          cat > ajv-patch.js << 'EOL'
          const fs = require('fs');
          const path = require('path');
          
          // Function to find and patch schema-utils validate.js files
          function patchSchemaUtils() {
            console.log('Looking for schema-utils validate.js files to patch...');
            
            // List of common paths where validate.js might be found
            const potentialPaths = [
              'node_modules/schema-utils/dist/validate.js',
              'node_modules/fork-ts-checker-webpack-plugin/node_modules/schema-utils/dist/validate.js',
              'node_modules/react-scripts/node_modules/schema-utils/dist/validate.js',
              'node_modules/babel-loader/node_modules/schema-utils/dist/validate.js',
              'node_modules/file-loader/node_modules/schema-utils/dist/validate.js',
              'node_modules/terser-webpack-plugin/node_modules/schema-utils/dist/validate.js',
              'node_modules/webpack/node_modules/schema-utils/dist/validate.js'
            ];
            
            // Check each potential path and patch if exists
            let patchCount = 0;
            potentialPaths.forEach(filePath => {
              if (fs.existsSync(filePath)) {
                console.log(`Patching ${filePath}`);
                try {
                  // Read file content
                  let content = fs.readFileSync(filePath, 'utf8');
                  
                  // Add a special patch to disable strict mode completely
                  if (content.includes('new _ajv')) {
                    // Replace the Ajv instantiation with one that has strict mode disabled
                    content = content.replace(
                      /new _ajv(\w*)\.default\((.*?)\)/g, 
                      'new _ajv$1.default({strict:false, allErrors:true})'
                    );
                    
                    // If ajvKeywords is used, adjust it to only use safe keywords
                    if (content.includes('ajvKeywords(ajv,')) {
                      content = content.replace(
                        /ajvKeywords\s*\(\s*ajv\s*,\s*\[(.*?)\]\s*\)/g,
                        'ajvKeywords(ajv, ["instanceof"]); try { ajv.addKeyword("link"); } catch(e) {}'
                      );
                    }
                    
                    // Write the patched content back
                    fs.writeFileSync(filePath, content);
                    patchCount++;
                  }
                } catch (err) {
                  console.error(`Error patching ${filePath}:`, err);
                }
              }
            });
            
            console.log(`Successfully patched ${patchCount} files.`);
            return patchCount > 0;
          }
          
          // Main patch function
          try {
            const success = patchSchemaUtils();
            if (success) {
              console.log('Patching completed successfully.');
            } else {
              console.log('No suitable files were found to patch.');
              // Even if nothing was patched, we don't want to fail the build
            }
          } catch (err) {
            console.error('Error during patching:', err);
            // Don't exit with error so build can continue
            console.log('Continuing with build despite patching errors.');
          }
          EOL
          
          # Run the patch script
          node ajv-patch.js || true  # Continue even if patching fails
          
          # Create a simple .npmrc to help with any remaining peer dependency issues
          echo "legacy-peer-deps=true" > .npmrc

      # Create API config file 
      - name: Create API Configuration
        run: |
          mkdir -p src/config
          cat > src/config/api.js << EOL
          // API configuration file - Auto-generated during deployment
          const API_URL = process.env.REACT_APP_API_URL || 'https://backend-sistema-asistencia-production.us-east-2.amazonaws.com';
          export default API_URL;
          EOL

      # Get API URL from previous workflow if available
      - name: Check for backend workflow trigger
        id: check-backend
        if: github.event_name == 'workflow_run'
        run: |
          echo "Triggered by backend deployment - retrieving API URL"
          echo "backend_triggered=true" >> $GITHUB_OUTPUT

      # Update API URL in the .env file
      - name: Setup environment configuration
        run: |
          if [ "${{ steps.check-backend.outputs.backend_triggered }}" == "true" ]; then
            # If triggered by backend, use its API URL if available
            # We have to pull the main branch as it may have been updated since our checkout
            git fetch origin main
            git checkout main
            echo "Using updated backend API URL from backend deployment"
          fi
          
          echo "REACT_APP_API_URL=${{ secrets.REACT_APP_API_URL }}" > .env
          echo "REACT_APP_BACKEND_STAGE=production" >> .env
          
          # Show what API URL we're using for debugging
          echo "Using API URL: ${{ secrets.REACT_APP_API_URL }}"

      - name: Build frontend
        run: |
          # Use NODE_OPTIONS to increase memory limit
          export NODE_OPTIONS="--max-old-space-size=4096 --no-warnings"
          
          # Try to build with multiple fallback options
          echo "Attempting to build with CRACO fallback method..."
          
          # First approach: Use DISABLE_ESLINT_PLUGIN to avoid any eslint issues
          DISABLE_ESLINT_PLUGIN=true CI=false GENERATE_SOURCEMAP=false npm run build || \
          
          # Second approach: If first approach fails, try using a simpler build command 
          (echo "First build attempt failed, trying backup approach..." && \
          NODE_ENV=production CI=false DISABLE_ESLINT_PLUGIN=true npx react-scripts build --no-strict)
        env:
          REACT_APP_API_URL: ${{ secrets.REACT_APP_API_URL }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-2

      # Use Amplify CLI to deploy the built artifacts
      - name: Deploy to AWS Amplify
        run: |
          # Install AWS Amplify CLI if not already available
          npm install -g @aws-amplify/cli

          # Create zip of the build folder
          cd build
          zip -r ../build.zip .
          cd ..

          # Start deployment to Amplify
          DEPLOYMENT_ID=$(aws amplify start-deployment \
            --app-id ${{ secrets.AMPLIFY_APP_ID }} \
            --branch-name main \
            --zip-file fileb://build.zip \
            --query 'jobId' \
            --output text)
          
          echo "Started deployment with ID: $DEPLOYMENT_ID"
          
          # Wait for deployment to complete
          aws amplify wait job-complete \
            --app-id ${{ secrets.AMPLIFY_APP_ID }} \
            --branch-name main \
            --job-id $DEPLOYMENT_ID

          echo "Deployment completed successfully" 