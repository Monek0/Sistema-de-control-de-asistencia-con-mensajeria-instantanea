name: Deploy Frontend to AWS Amplify

on:
  push:
    branches:
      - main
    paths:
      - 'Plataforma_Atrasos/frontend/**'
      - '.github/workflows/deploy-amplify.yml'
  workflow_run:
    workflows: ["Deploy Backend to AWS Lambda"]
    types:
      - completed
    branches:
      - main
  workflow_dispatch:

jobs:
  deploy:
    name: Deploy Frontend
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: Plataforma_Atrasos/frontend

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 18
          cache: 'npm'
          cache-dependency-path: Plataforma_Atrasos/frontend/package-lock.json

      - name: Install dependencies
        run: |
          # Create .npmrc to handle peer dependencies
          echo "legacy-peer-deps=true" > .npmrc
          
          # Clean install
          npm cache clean --force
          npm install --legacy-peer-deps

      - name: Fix Ajv errors
        run: |
          # Create a patch script for Ajv
          cat > ajv-patch.js << 'EOL'
          const fs = require('fs');
          const path = require('path');
          
          // Function to recursively find files
          function findFiles(dir, pattern, callback) {
            fs.readdirSync(dir).forEach(file => {
              const filePath = path.join(dir, file);
              const stat = fs.statSync(filePath);
              if (stat.isDirectory()) {
                findFiles(filePath, pattern, callback);
              } else if (pattern.test(file)) {
                callback(filePath);
              }
            });
          }
          
          // Patch Ajv's main validator files
          function patchAjv() {
            console.log('Patching Ajv files...');
            
            // Find all validate.js files in schema-utils directories
            findFiles('./node_modules', /validate\.js$/, (filePath) => {
              if (filePath.includes('schema-utils')) {
                console.log(`Patching ${filePath}`);
                let content = fs.readFileSync(filePath, 'utf8');
                
                // Add strict:false option to Ajv constructor
                content = content.replace(
                  /new _ajv(\w*)\.default\((.*?)\)/g, 
                  'new _ajv$1.default({strict:false,$2})'
                );
                
                // Allow 'link' keyword by adding it to allowUnknown option
                content = content.replace(
                  /ajvKeywords\(ajv,.*?\)/g,
                  'ajvKeywords(ajv, ["instanceof"]); ajv.addKeyword("link"); ajv._opts.strict = false'
                );
                
                fs.writeFileSync(filePath, content);
              }
            });
            
            // Patch Ajv's main files
            findFiles('./node_modules/ajv', /index\.js$/, (filePath) => {
              console.log(`Checking Ajv file: ${filePath}`);
              const content = fs.readFileSync(filePath, 'utf8');
              
              // Only patch files that seem to be main Ajv modules
              if (content.includes('function Ajv') || content.includes('class Ajv')) {
                console.log(`Patching Ajv core file: ${filePath}`);
                let newContent = content;
                
                // Make sure unknown keywords don't cause errors
                if (!content.includes('this._opts.strict = false')) {
                  // Add code to disable strict mode
                  newContent = content.replace(
                    /constructor\s*\([^)]*\)\s*{/,
                    'constructor(opts) { if (opts) { opts.strict = false; } else { opts = {strict: false}; }'
                  );
                  
                  // If not a class-based file, try function style
                  if (newContent === content) {
                    newContent = content.replace(
                      /function Ajv\s*\([^)]*\)\s*{/,
                      'function Ajv(opts) { if (opts) { opts.strict = false; } else { opts = {strict: false}; }'
                    );
                  }
                  
                  fs.writeFileSync(filePath, newContent);
                }
              }
            });
            
            console.log('Patching complete.');
          }
          
          // Execute the patch
          try {
            patchAjv();
            console.log('Successfully patched Ajv to handle unknown keywords');
          } catch (err) {
            console.error('Error patching Ajv:', err);
            process.exit(1);
          }
          EOL
          
          # Run the patch script
          node ajv-patch.js

      # Create API config file 
      - name: Create API Configuration
        run: |
          mkdir -p src/config
          cat > src/config/api.js << EOL
          // API configuration file - Auto-generated during deployment
          const API_URL = process.env.REACT_APP_API_URL || 'https://backend-sistema-asistencia-production.us-east-2.amazonaws.com';
          export default API_URL;
          EOL

      # Get API URL from previous workflow if available
      - name: Check for backend workflow trigger
        id: check-backend
        if: github.event_name == 'workflow_run'
        run: |
          echo "Triggered by backend deployment - retrieving API URL"
          echo "backend_triggered=true" >> $GITHUB_OUTPUT

      # Update API URL in the .env file
      - name: Setup environment configuration
        run: |
          if [ "${{ steps.check-backend.outputs.backend_triggered }}" == "true" ]; then
            # If triggered by backend, use its API URL if available
            # We have to pull the main branch as it may have been updated since our checkout
            git fetch origin main
            git checkout main
            echo "Using updated backend API URL from backend deployment"
          fi
          
          echo "REACT_APP_API_URL=${{ secrets.REACT_APP_API_URL }}" > .env
          echo "REACT_APP_BACKEND_STAGE=production" >> .env
          
          # Show what API URL we're using for debugging
          echo "Using API URL: ${{ secrets.REACT_APP_API_URL }}"

      - name: Build frontend
        run: |
          # Use NODE_OPTIONS to increase memory limit
          export NODE_OPTIONS="--max-old-space-size=4096 --no-warnings"
          
          # Try to build with React scripts, disabling strict mode
          DISABLE_ESLINT_PLUGIN=true CI=false GENERATE_SOURCEMAP=false npm run build
        env:
          REACT_APP_API_URL: ${{ secrets.REACT_APP_API_URL }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-2

      # Use Amplify CLI to deploy the built artifacts
      - name: Deploy to AWS Amplify
        run: |
          # Install AWS Amplify CLI if not already available
          npm install -g @aws-amplify/cli

          # Create zip of the build folder
          cd build
          zip -r ../build.zip .
          cd ..

          # Start deployment to Amplify
          DEPLOYMENT_ID=$(aws amplify start-deployment \
            --app-id ${{ secrets.AMPLIFY_APP_ID }} \
            --branch-name main \
            --zip-file fileb://build.zip \
            --query 'jobId' \
            --output text)
          
          echo "Started deployment with ID: $DEPLOYMENT_ID"
          
          # Wait for deployment to complete
          aws amplify wait job-complete \
            --app-id ${{ secrets.AMPLIFY_APP_ID }} \
            --branch-name main \
            --job-id $DEPLOYMENT_ID

          echo "Deployment completed successfully" 